diff --git a/src/main/scala/boids/Benchmarks.scala b/src/main/scala/boids/Benchmarks.scala
index 7e262f9..cbd5eb1 100644
--- a/src/main/scala/boids/Benchmarks.scala
+++ b/src/main/scala/boids/Benchmarks.scala
@@ -5,6 +5,7 @@ import scala.util.Random
 import cs214.Vector2
 import org.openjdk.jmh.annotations.Benchmark
 import boids.Benchmarks.generateRandomBoids
+import boids.Benchmarks.defaultPhysics
 
 /** Supporting elements for benchmarks
   */
@@ -72,6 +73,6 @@ class Benchmarks:
   def tickWorldComplete1K =
     val allBoids = generateRandomBoids(1000)
     // UNCOMMENT THIS WHEN YOU HAVE CONVERTED EVERYTHING TO VECTORS
-    // tickWorld(allBoids, defaultPhysics)
+    tickWorld(allBoids, defaultPhysics)
 
 end Benchmarks
diff --git a/src/main/scala/boids/BoidLogic.scala b/src/main/scala/boids/BoidLogic.scala
index eced7e8..d437560 100644
--- a/src/main/scala/boids/BoidLogic.scala
+++ b/src/main/scala/boids/BoidLogic.scala
@@ -1,38 +1,41 @@
 package boids
-import cs214.{Vector2, BoidSequence}
+import cs214.{Vector2}
 import scala.collection.parallel.CollectionConverters.* // access to .par methods
+import boids.conversions.FluidBoidVecs.given_Conversion_Vector_BoidSequence
+
 import boids.conversions.NumericVectors.given
 
-def boidsWithinRadius(thisBoid: Boid, boids: BoidSequence, radius: Float): BoidSequence =
-  boids.filter(b =>
+def boidsWithinRadius(thisBoid: Boid, boids: Vector[Boid], radius: Float): Vector[Boid] =
+  boids.par.filter(b =>
     b != thisBoid &&
       b.position.distanceTo(thisBoid.position) < radius
-  )
+  ).seq
 
-def avoidanceForce(thisBoid: Boid, boidsWithinAvoidanceRadius: BoidSequence): cs214.Vector2 =
+  // Parallel computation of avoidance force
+def avoidanceForce(thisBoid: Boid, boidsWithinAvoidanceRadius: Vector[Boid]): cs214.Vector2 =
   boidsWithinAvoidanceRadius
-    .mapVector2(b => thisBoid.position - b.position)
+    .map(b => thisBoid.position - b.position)
     .filter(_.norm > 0)
     .map(diff => diff / (diff.norm * diff.norm))
     .sum
 
-def cohesionForce(thisBoid: Boid, boidsWithinPerceptionRadius: BoidSequence): cs214.Vector2 =
+def cohesionForce(thisBoid: Boid, boidsWithinPerceptionRadius: Vector[Boid]): cs214.Vector2 =
   if boidsWithinPerceptionRadius.isEmpty then
     Vector2.Zero
   else
-    boidsWithinPerceptionRadius.mapVector2(_.position).sum
+    boidsWithinPerceptionRadius.map(_.position).sum
       / boidsWithinPerceptionRadius.length.toFloat
       - thisBoid.position
 
-def alignmentForce(thisBoid: Boid, boidsWithinPerceptionRadius: BoidSequence): cs214.Vector2 =
+def alignmentForce(thisBoid: Boid, boidsWithinPerceptionRadius: Vector[Boid]): cs214.Vector2 =
   if boidsWithinPerceptionRadius.isEmpty then
     Vector2.Zero
   else
-    boidsWithinPerceptionRadius.mapVector2(_.velocity).sum
+    boidsWithinPerceptionRadius.par.map(_.velocity).sum
       / boidsWithinPerceptionRadius.length.toFloat
       - thisBoid.velocity
 
-def containmentForce(thisBoid: Boid, allBoids: BoidSequence, width: Int, height: Int): cs214.Vector2 =
+def containmentForce(thisBoid: Boid, allBoids: Vector[Boid], width: Int, height: Int): cs214.Vector2 =
   val horizontalForce =
     if thisBoid.position.x < 0 then Vector2.UnitRight
     else if thisBoid.position.x > width then Vector2.UnitLeft
@@ -43,7 +46,7 @@ def containmentForce(thisBoid: Boid, allBoids: BoidSequence, width: Int, height:
     else Vector2.Zero
   horizontalForce + verticalForce
 
-def totalForce(thisBoid: Boid, allBoids: BoidSequence, physics: Physics): Vector2 =
+def totalForce(thisBoid: Boid, allBoids: Vector[Boid], physics: Physics): Vector2 =
   val withinPerceptionRadius = boidsWithinRadius(thisBoid, allBoids, physics.perceptionRadius)
   val cohere = cohesionForce(thisBoid, withinPerceptionRadius)
   val align = alignmentForce(thisBoid, withinPerceptionRadius)
@@ -65,7 +68,7 @@ def clampVelocity(velocity: cs214.Vector2, minimumSpeed: Float, maximumSpeed: Fl
   else
     velocity
 
-def tickBoid(thisBoid: Boid, allBoids: BoidSequence, physics: Physics): Boid =
+def tickBoid(thisBoid: Boid, allBoids: Vector[Boid], physics: Physics): Boid =
   val acceleration = totalForce(thisBoid, allBoids, physics)
   Boid(
     thisBoid.position + thisBoid.velocity,
@@ -76,5 +79,5 @@ def tickBoid(thisBoid: Boid, allBoids: BoidSequence, physics: Physics): Boid =
     )
   )
 
-def tickWorld(allBoids: BoidSequence, physics: Physics): BoidSequence =
-  allBoids.mapBoid(boid => tickBoid(boid, allBoids, physics))
+def tickWorld(allBoids: Vector[Boid], physics: Physics): Vector[Boid] =
+  allBoids.par.map(boid => tickBoid(boid, allBoids, physics)).seq
diff --git a/src/main/scala/howManyHoursISpentOnThisLab.scala b/src/main/scala/howManyHoursISpentOnThisLab.scala
index 50d7ba5..a368e25 100644
--- a/src/main/scala/howManyHoursISpentOnThisLab.scala
+++ b/src/main/scala/howManyHoursISpentOnThisLab.scala
@@ -1,2 +1,2 @@
 def howManyHoursISpentOnThisLab(): Double =
-  0.0 // in hours, so put 3.5 here if you spent 3 hours and a half on the lab
+  0.3// in hours, so put 3.5 here if you spent 3 hours and a half on the lab
